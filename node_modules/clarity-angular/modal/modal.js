"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var core_1 = require("@angular/core");
var scrolling_service_1 = require("../main/scrolling-service");
var index_1 = require("../animations/fade-slide/index");
var index_2 = require("../animations/fade/index");
var Modal = (function () {
    function Modal(_scrollingService) {
        this._scrollingService = _scrollingService;
        // We grab animated children from the view, to wait for them to finish animating out
        // before completely hiding the component itself.
        this._open = false;
        this._openChanged = new core_1.EventEmitter(false);
        this.closable = true;
        this.staticBackdrop = false;
    }
    Object.defineProperty(Modal.prototype, "sizeClass", {
        get: function () {
            if (this.size) {
                return "modal-" + this.size;
            }
            else {
                return "";
            }
        },
        enumerable: true,
        configurable: true
    });
    //Detect when _open is set to true and set no-scrolling to true
    Modal.prototype.ngOnChanges = function (changes) {
        if (changes && changes.hasOwnProperty("_open")) {
            if (changes["_open"].currentValue) {
                this._scrollingService.stopScrolling();
            }
            else {
                this._scrollingService.resumeScrolling();
            }
        }
    };
    Modal.prototype.ngOnDestroy = function () {
        this._scrollingService.resumeScrolling();
    };
    Modal.prototype.open = function () {
        this._open = true;
        this._openChanged.emit(true);
    };
    Modal.prototype.close = function () {
        if (!this.closable) {
            return;
        }
        this._open = false;
        this._openChanged.emit(false);
    };
    // FIXME: When Angular offers key filtering on global events, this should be replaced by:
    //  @HostListener("body:keyup.escape")"
    // on the close() method.
    Modal.prototype.globalKeyUp = function (keyCode) {
        // Close when the user presses escape
        if (keyCode === 27) {
            this.close();
        }
    };
    __decorate([
        core_1.Input("clrModalOpen"), 
        __metadata('design:type', Boolean)
    ], Modal.prototype, "_open", void 0);
    __decorate([
        core_1.Output("clrModalOpenChange"), 
        __metadata('design:type', core_1.EventEmitter)
    ], Modal.prototype, "_openChanged", void 0);
    __decorate([
        core_1.Input("clrModalClosable"), 
        __metadata('design:type', Boolean)
    ], Modal.prototype, "closable", void 0);
    __decorate([
        core_1.Input("clrModalSize"), 
        __metadata('design:type', String)
    ], Modal.prototype, "size", void 0);
    __decorate([
        core_1.Input("clrModalStaticBackdrop"), 
        __metadata('design:type', Boolean)
    ], Modal.prototype, "staticBackdrop", void 0);
    __decorate([
        core_1.HostListener("body:keyup", ["$event.keyCode"]), 
        __metadata('design:type', Function), 
        __metadata('design:paramtypes', [Number]), 
        __metadata('design:returntype', void 0)
    ], Modal.prototype, "globalKeyUp", null);
    Modal = __decorate([
        core_1.Component({
            selector: "clr-modal",
            viewProviders: [scrolling_service_1.ScrollingService],
            template: "\n\n      <div class=\"modal\" *ngIf=\"_open\">\n          <!--fixme: revisit when ngClass works with exit animation-->\n          <div [@fadeDown] class=\"modal-dialog\"\n               [class.modal-sm]=\"size == 'sm'\"\n               [class.modal-lg]=\"size == 'lg'\"\n               [class.modal-xl]=\"size == 'xl'\"\n               role=\"dialog\" aria-hidden=\"true\">\n              <div class=\"modal-content\">\n                  <div class=\"modal-header\">\n                      <button type=\"button\" class=\"close\" aria-label=\"Close\"\n                              *ngIf=\"closable\" (click)=\"close()\">\n                          <span aria-hidden=\"true\">&times;</span>\n                      </button>\n                      <ng-content select=\".modal-title\"></ng-content>\n                  </div>\n                  <ng-content select=\".modal-body\"></ng-content>\n                  <ng-content select=\".modal-footer\"></ng-content>\n              </div>\n          </div>\n\n          <div [@fade] class=\"modal-backdrop\"\n               aria-hidden=\"true\"\n               (click)=\"staticBackdrop || close()\"></div>\n      </div>\n    ",
            styles: ["\n        :host { display: inline-block; }\n    "],
            animations: [
                core_1.trigger("fadeDown", index_1.fadeSlide("down")),
                core_1.trigger("fade", index_2.fade(0.85))
            ]
        }), 
        __metadata('design:paramtypes', [scrolling_service_1.ScrollingService])
    ], Modal);
    return Modal;
}());
exports.Modal = Modal;
