<article>
    <h5 class="component-summary" id="a-wizard-presents-a-multi-step-workflow-that-users-perform-in-a-recommended-sequence">A wizard presents a multi-step workflow that users perform in a recommended sequence.</h5>

    <h3 id="html-and-styles">HTML and Styles</h3>

    <p>Here is an example of the generated wizard markup using just HTML and CSS. Since the interactive functionality of the wizard is not provided in the static version, we recommend using the Angular component.</p>

    <clr-wizard-demo-static></clr-wizard-demo-static>

    <h3 id="basic-wizard">Basic Wizard</h3>

    <p>
        The wizard is hidden and shown by toggling a boolean value assigned to the
        <code class="clr-code">clrWizardOpen</code> input. The toggling of these values is
        shown in the code examples below.
    </p>

    <p>
        Note that you will probably want unique booleans for hiding and showing wizards
        when you have more than one wizard on a page. If hiding and showing are all assigned
        to the same boolean, the wizards will all hide and show together. This is probably
        not the intended experience.
    </p>

    <p>
        The wizard comes in three different sizes: medium, large, and extra-large. You can set
        the size by providing the value as an input &mdash; <code class="clr-code">clrWizardSize</code>.
        If not specified, the wizard will <b>default to extra-large</b>. Sizing options for 
        <code class="clr-code">clrWizardSize</code> are: <code class="clr-code">md</code>,
        <code class="clr-code">lg</code>, and <code class="clr-code">xl</code>.
    </p>

    <clr-wizard-basic></clr-wizard-basic>

    <h3 id="skipping-and-unskipping-steps">Skipping and unskipping steps</h3>

    <p>
        Depending on the flow of the wizard, you may want to skip or add steps in the wizard.
        In the 0.9.0 wizard, this is accomplished by using the <code class="clr-code">*ngIf</code>
        Angular directive.
    </p>

    <clr-wizard-simple></clr-wizard-simple>

    <h4 id="skipping-with-ngfor">Skipping steps and *ngFor</h4>

    <p>
        If you are using <code class="clr-code">*ngFor</code> to generate your wizard pages and
        still want to use <code class="clr-code">*ngIf</code> to hide them, you will want to
        follow <a href="https://angular.io/docs/ts/latest/guide/structural-directives.html#!#one-per-element"
        target="_blank">the Angular team's recommendations on nested structural directives</a>.
    </p>

    <p>
        At a high level, this means wrapping your <code class="clr-code">&lt;clr-wizard-page 
        *ngIf="yourCondition"&gt;</code> inside a <code class="clr-code">&lt;ng-container 
        *ngFor="let page of pages"&gt;</code> element.
    </p>

    <p>
        Alternatively, you could add and remove elements from the array of pages you are sending
        to the <code class="clr-code">*ngFor</code>.
    </p>

    <clr-wizard-nested-directives></clr-wizard-nested-directives>

    <h3 id="jumping-to-a-step">Programmatically navigating the wizard</h3>

    <p>
        There may be times when you need end-users to jump to a specific step in a wizard. The
        way to do this is to call the <code class="clr-code">setCurrentPage()</code> method on
        the <code class="clr-code">WizardNavigationService</code> provider of the wizard.
    </p>
    <p>
        The safest way to ensure that end-users do not wind up in a bad state is to make sure
        that the page to which they are navigating is completed and, if not, send users to the
        last valid page using the <code class="clr-code">setLastEnabledPageCurrent()</code>
        method on the same <code class="clr-code">WizardNavigationService</code>
        provider, as in the example below.
    </p>

    <clr-wizard-jump-to></clr-wizard-jump-to>

    <h3 id="overriding-the-title-in-the-wizard-page">Different Page Title in the Sidenav</h3>

    <p>
        By default, the nav item on the right-hand side will display the same title as the title 
        inside the <code class="clr-code">&lt;ng-template clrPageTitle&gt;</code> in your
        <code class="clr-code">&lt;clr-wizard-page&gt;</code>. In fact, this is the <em>only</em>
        element that is required inside your <code class="clr-code">&lt;clr-wizard-page&gt;</code>.
        It provides not only the title at the top of the content area but also the item in the 
        sidenav to the left.
    </p>

    <p>
        Sometimes, however, having the title in the content area match the nav item is not a
        desired behavior. The title in the content area may be too long or the nav item may
        need to update based on changes elsewhere in the wizard.
    </p>

    <p>
        To accomplish this customization, you can use a <code
        class="clr-code">&lt;ng-template clrPageNavTitle&gt;</code> element. When placed inside,
        a <code class="clr-code">&lt;clr-wizard-page&gt;</code>, a <code class="clr-code">clrPageNavTitle</code>
        template reference will be used in the nav sidebar of the wizard instead of the content title.
    </p>

    <p>
        As with any Angular content, you can also use projection to change the titles in either a
        <code class="clr-code">clrPageTitle</code> or <code class="clr-code">clrPageNavTitle</code>
        whenever you need to.
    </p>

    <clr-wizard-titles></clr-wizard-titles>

    <h3 id="custom-page-buttons">Overriding buttons at the page level</h3>

    <p>
        As part of creating a wizard, you need to include a set of default buttons of types finish,
        next, previous, and cancel as a direct child of your <code
        class="clr-code">&lt;clr-wizard&gt;</code> element.
    </p>

    <clr-wizard-default-buttons></clr-wizard-default-buttons>

    <p>
        These buttons can be overridden at the page level, however, with other buttons of the same
        type (but with different text) or with completely custom buttons. To override the default
        buttons, include a new set of buttons inside a <code class="clr-code">&lt;ng-template clrPageButtons&gt;</code>
        template reference element. Sets of buttons defined at the page level will override the
        default buttons defined at the wizard level.
    </p>

    <h3 id="custom-buttons">Custom buttons and page-level button overrides</h3>

    <p>
        A <em>page override</em> is defining a button at the page level in place of a button of the same type at the
        wizard level. These types include finish, danger, next, previous, and cancel. If you override the
        click events of these buttons with an output like <code class="clr-code">clrWizardPagePreventDefault</code>,
        you can also short-circuit the default action of the button to define your own custom action at the
        page level.
    </p>

    <p>
        A <em>custom button</em> is a different beast entirely. Custom buttons are not like
        page overrides. They have no action assigned to them. So you will need to use the
        <code class="clr-code">clrWizardPageCustomButton</code> output to assign an action to your custom
        buttons. The output receives the custom button type which should allow you to route your wizard's
        behavior based on the type of button it receives.
    </p>

    <p>
        You can use specified custom button types such as <code class="clr-code">custom-finish</code>,
        <code class="clr-code">custom-next</code>,
        <code class="clr-code">custom-danger</code>,
        <code class="clr-code">custom-previous</code>, or
        <code class="clr-code">custom-cancel</code> to have your custom buttons inherit the styling
        of the button listed in the latter part of the button type. Note, however, that these
        custom buttons <em>do not</em> kick off the actions associated with their styled types.
        You have to tell a wizard what you want a button to do.
    </p>

    <p>
        By default, a custom button will be styled as an outline button. Meaning it will look like a
        "previous" type of button. For example, you would get an action blue, outlined button with the
        text "Wallaby" inside it if you created a button with the following declaration:
        <code class="clr-code">&lt;clr-wizard-button [type]="'wallaby'"&gt;Wallaby&lt;/clr-wizard-button&gt;</code>.
        And if your page was listening to the <code class="clr-code">clrWizardPageCustomButton</code> output,
        your event handler would receive the button type <code class="clr-code">wallaby</code> as a parameter
        when the custom button was clicked.
    </p>

    <p>
        Reference the following example:
    </p>

    <clr-wizard-custom-buttons></clr-wizard-custom-buttons>

    <h3 id="wizard-with-form-validation">Wizard with Form Validation</h3>

    <p>
        You can use form validation with the wizard. If you wish to disable the next button until
        the form is valid, you can do so by setting the
        <code class="clr-code">clrWizardPageNextDisabled</code> input of the
        <code class="clr-code">&lt;clr-wizard-page&gt;</code> to the form’s valid property as shown
        in the example.
    </p>

    <p>
        Note also in the example how the text of the third step nav item changes as the form is
        validated.
    </p>

    <clr-wizard-form-validation></clr-wizard-form-validation>

    <h3 id="wizard-with-asynchronous-validation">Wizard with Asynchronous Validation</h3>

    <p>
        Some applications may need to make an an asynchronous call for server-side
        validation of form input. The example below demonstrates how you can prevent
        the wizard from moving forward with the next button by setting the <code class="clr-code">clrWizardPagePreventDefault</code> input to false. Then enable it
        by programmatically calling next when the asynchronous form validation passes.
    </p>

    <clr-wizard-async-validation></clr-wizard-async-validation>

    <h3 id="wizard-with-asynchronous-completion">Wizard with Asynchronous Completion</h3>

    <p>
        While not a recommended pattern, some applications need to validate data before
        finishing the wizard &mdash; as opposed to the sort of page-to-page validation
        demonstrated above.
    </p>

    <p>
        The approach to doing this on the final page of a wizard is very similar to validating
        each page with the only twist being where the <code class="clr-code">finish()</code>
        method should be called.
    </p>

    <clr-wizard-async-completion></clr-wizard-async-completion>

    <h3>Resetting the wizard</h3>

    <p>
        While the easiest way to restore a wizard back to its pristine state is to destroy and
        recreate it, there are use cases where this is not feasible. If you need to reset
        the wizard while it is open, destroying and recreating it would be a poor experience
        for users. Likewise, some applications are architected such that it is less expensive
        to reuse an instance of a wizard instead of destroying it and making the backend
        calls necessary to re-initialize a new instance.
    </p>

    <p>
        The Clarity wizard includes a <code class="clr-code">reset()</code> convenience method.
        In order to use it, you would need a reference to the wizard in your host component and
        can call reset from there. In the example below, we use <code
        class="clr-code">wizard.reset()</code> which references the ViewChild
        <code class="clr-code">&lt;clr-wizard #wizard&gt;</code> in the host component's template.
    </p>

    <p>
        The <code class="clr-code">reset()</code> method resets the wizard's
        navigation and page state. So it clears out any pages that were
        marked completed and sets the active page back to the first page of the wizard.
    </p>

    <p>
        When resetting the wizard, it is your responsibility to reset your wizard's
        model. This can be done either as part of the action that calls the reset, as in
        the example below, or with an event handler that listens to the
        <code class="clr-code">clrWizardOnReset</code> output.
    </p>

    <clr-wizard-reset></clr-wizard-reset>

    <h3 id="alternative-cancel">Providing an alternative cancel for the wizard</h3>

    <p>
        The Clarity wizard allows users to circumvent the default cancel/close action at
        both the page and wizard level to enable their own functionality to validate,
        prompt users, or reset their data.
    </p>
    <p>
        At the wizard level, setting the <code class="clr-code">clrWizardPreventDefaultCancel</code>
        input to true prevents the wizard’s cancel routine from running on any page. When the
        <code class="clr-code">clrWizardPreventDefaultCancel</code> input is set, users must
        also assign an event handler to the <code class="clr-code">clrWizardOnCancel</code>
        output and manually call <code class="clr-code">close()</code> on their instance of
        the wizard for the cancel action to take effect.
    </p>
    <p>
        That cancel/close functionality of the wizard can also be overridden at the page
        level. Users must set the <code class="clr-code">clrWizardPagePreventDefaultCancel</code>
        input to true on the <code class="clr-code">&lt;clr-wizard-page&gt;</code> declaration
        and likewise supply an event handler to the
        <code class="clr-code">clrWizardPageOnCancel</code> output. This event handler will
        also need to manually call <code class="clr-code">close()</code> for the expected
        wizard cancel functionality to take effect.
    </p>
    <p>
        In the case of a conflict where the cancel action is overridden at both the page and
        wizard levels, the page level takes precedence.
        <code class="clr-code">clrWizardOnCancel</code> will never be emitted. The example
        below demonstrates this.
    </p>

    <clr-wizard-alt-cancel></clr-wizard-alt-cancel>

    <h5 id="no-cancel">But what if I do not want any cancel buttons?</h5>

    <p>
         There are times when you may want your end-users to finish hey wizard before
         they can do anything else. This may include installation routines or set up
         of your application. In these instances, it makes sense to use a wizard that
         does not have a cancel button and is also not closable.
    </p>
    <p>
        If you do not want a cancel action in your wizard, do not include a cancel
        button in your default set of buttons or do not include it in your
        <code class="clr-code">&lt;ng-template clrPageButtons&gt;</code> template
        reference at the page level.
    </p>
    <p>
        This also applies to other button types like previous or next. Note, however,
        that omission of next, previous, and finish buttons is not recommended and
        could confuse end-users of your application.
    </p>
    <p>
        The example below demonstrates a wizard without cancel buttons that is also
        set to not be closable. The only way to close it is to the click all the way
        through it.
    </p>

    <clr-wizard-no-cancel></clr-wizard-no-cancel>

    <h3 id="alternative-cancel">Providing an alternative next for the wizard</h3>

    <p>
        Just like with <code class="clr-code">clrWizardPreventDefaultCancel</code>,
        the Clarity wizard allows users to override the default primary button actions at
        both the page and wizard level. This includes danger, finish, and next buttons.
    </p>
    <p>
        The use case for this is when you want the wizard to validate its contents
        whenever the next button is clicked. It is less overt than manipulating the
        <code class="clr-code">clrWizardPageNextDisabled</code> to enable or disable
        a wizard page's primary buttons, as demonstrated in the form validation example above.
    </p>
    <p>
        Overriding next, finish, and danger buttons at the wizard level involves setting
        the <code class="clr-code">clrWizardPreventDefaultNext</code>
        input to true. This prevents the wizard from executing the built-in methods that finish
        the wizard and move the wizard to the next page.
    </p>
    <p>
        Using <code class="clr-code">clrWizardPreventDefaultNext</code> requires that you handle
        the <code class="clr-code">clrWizardOnNext</code> and
        <code class="clr-code">clrWizardOnFinish</code> event emitters in your host component's
        code. These routines will need to call
        <code class="clr-code">wizard.forceNext()</code> and
        <code class="clr-code">wizard.forceFinish()</code>, respectively.
        <code class="clr-code">forceNext()</code> and <code class="clr-code">forceFinish()</code>
        perform the work of finishing the wizard and moving it to the next page without the
        checks and event emissions involved with calling the default
        <code class="clr-code">next()</code> and <code class="clr-code">finish()</code>
        methods in the wizard.
    </p>
    <p>
        You can override the primary button actions at a page level by using the
        <code class="clr-code">clrWizardPagePreventDefaultNext</code>
        input.
    </p>
    <p>
        As with wizard level overrides, you will need to provide an event handler for
        the <code class="clr-code">clrWizardPageNext</code> and
        <code class="clr-code">clrWizardPageFinish</code> outputs. If your specific page
        does not have a finish button, there is no need to handle
        the <code class="clr-code">clrWizardPageFinish</code> event. The same holds true
        for wizard pages that do not have next buttons.
    </p>
    <p>
        Also similar to the output routines at the wizard level, your page-level methods will
        need to manually call the <code class="clr-code">wizard.forceNext()</code> and
        <code class="clr-code">wizard.forceFinish()</code> methods to bring that functionality
        back to the overridden page.
    </p>
    <p>
        Just like with the cancel overrides, the page level override is used in place of the
        wizard level override when a specific page has them both set. The example
        below shows how this happens.
    </p>

    <clr-wizard-alt-next></clr-wizard-alt-next>

    <h3 id="non-closable-wizard">Non-Closable Wizard</h3>

    <p>In some circumstances, you may want to not show the closing × icon in the top right of the Wizard modal. You can remove this close × icon by setting the
        <code class="clr-code">clrWizardClosable</code> input to <code class="clr-code">false</code>.</p>

    <clr-wizard-not-closable></clr-wizard-not-closable>
    <h3 id="clarity-wizard-deep-dive">Clarity wizard deep-dive</h3>

    <p>
        The Clarity wizard is a complex component made up of a number of subcomponents. Each
        Clarity wizard also has a number of services whose chief responsibility is handling
        communication between the wizard and its subcomponents.
    </p>

    <p>
        The subcomponents that make up the wizard include a collection of buttons, wizard pages,
        the “step-nav” to the left of the wizard’s content area, and the “step-nav items” which
        constitute the links that appear in the step-nav.
    </p>

    <p>
        The Clarity wizard also has a number of providers (services). The most important of these
        services are the <code class="clr-code">WizardNavigationService</code> and the
        <code class="clr-code">PageCollectionService</code>. At a high-level, the
        <code class="clr-code">WizardNavigationService</code> (or “nav service”) manages the state
        of the current page in a wizard, as well as functionality and communication related to
        making pages current. The <code class="clr-code">PageCollectionService</code> (or “page
        collection”) handles functionality that treats the pages within a wizard as a group of objects.
    </p>
    <p>
        In the following sections, we will briefly touch upon the most important components and
        services related to the wizard, as well as their most notable inputs, outputs, and public
        methods and properties.
    </p>

    <h5>The wizard</h5>

    <p>
        The wizard component is a sort of meta-component that brings together a group of services
        and subcomponents. Most of the time, everything you need to do with the wizard can be done
        through a reference to the wizard in your host component.
    </p>

<pre><code clr-code-highlight="language-typescript">@Component(&#123;
    ...
&#125;)
export class WizardJumpToDemo &#123;
    @ViewChild("ohai") wizard: Wizard; // makes wizard accessible through this.wizard!!!
    ...
</code></pre>

<pre><code clr-code-highlight="language-html">&lt;clr-wizard #ohai [(clrWizardOpen)]="open">
    &lt;!-- the '#wizard' up there creates the reference that your ViewChild property looks for --&gt;
    &lt;clr-wizard-title&gt;Your Wizard&lt;/clr-wizard-title&gt;
    ...
</code></pre>

    <p>
        Because the wizard’s functionality involves mostly monitoring the state and managing
        communications with child components, the wizard expects some subcomponents to be declared in order for
        it to avoid an existential crisis.
    </p>

    <p>
        Every wizard needs a <code class="clr-code">&lt;clr-wizard-title&gt;</code>,
        <code class="clr-code">&lt;clr-wizard-button&gt;</code>, and at least one
        <code class="clr-code">&lt;clr-wizard-page&gt;</code> component to be declared as
        its children. If these sub-components are not present, the wizard will throw an error.
    </p>

    <p>
        As a convenience, wizards give you hooks to all of their services. If you have a reference to
        the wizard in your host component as in the example above, you can access all of the important
        nav service and page collection functionality. Specifically, the above example could call
        <code class="clr-code">this.wizard.navService</code> or
        <code class="clr-code">this.wizard.pageCollection</code> to access the nav service or page
        collection, respectively.
    </p>

    <h6>Inputs of note</h6>
    <ul class="list">
        <li>
            <b>clrWizardSize</b> (string) sets the size of the wizard. Acceptable values are 
            <code class="clr-code">md</code>, <code class="clr-code">lg</code>, and
            <code class="clr-code">xl</code> representing medium, large, and extra-large wizards.
            <code class="clr-code">xl</code> is default.
        </li>
        <li>
            <code class="clr-code">clrWizardClosable</code>> (boolean) hides or reveals the
            close “X” in the top right. If false, the close “X” will not be present. The property
            defaults to true.
        </li>
        <li>
            <code class="clr-code">clrWizardOpen</code>> (boolean) hides or shows the wizard, in
            the same way that <code class="clr-code">clrModalOpen</code> hides or shows a modal.
        </li>
        <li>
            <code class="clr-code">clrWizardPreventDefaultCancel</code>> (boolean) prevents a
            user’s cancel action from closing the wizard. Defaults to false.
        </li>
    </ul>

    <h6>Outputs of note</h6>
    <ul class="list">
        <li>
            <code class="clr-code">clrWizardOpenChange</code>> is an output that fires an event
            after the wizard has opened.
        </li>
        <li>
            <code class="clr-code">clrWizardOnCancel</code>> fires an event after the wizard has
            been canceled and, in most cases, closed. This output can be used with the
            <code class="clr-code">clrWizardPreventDefaultCancel</code> input to
            implement custom functionality when a user wants to close or cancel a wizard.
        </li>
        <li>
            <code class="clr-code">clrWizardOnFinish</code>> emits an event after a wizard has
            been completed &mdash; once the finish button on the last page has been clicked. If
            you wanted to reset the wizard after it was finished, this would be a good output to consider.
        </li>
        <li>
            <code class="clr-code">clrWizardOnReset</code>> emits an event after the wizard has
            reset all of its pages to incomplete and also reset its navigation to make the first
            page in the step nav current.
        </li>
        <li>
            <code class="clr-code">clrWizardCurrentPageChanged</code>> is fired after the current
            page of the wizard has been changed.
        </li>
    </ul>

    <h6>Useful properties on the wizard</h6>
    <ul class="list">
        <li>
            <code class="clr-code">wizard.currentPage</code> will retrieve the current page
            object (<code class="clr-code">WizardPage</code>) of the wizard.
        </li>
        <li>
            <code class="clr-code">wizard.isLast</code> returns a boolean telling you if the
            current page is the last page in the wizard.
        </li>
        <li>
            <code class="clr-code">wizard.isFirst</code> will also return a boolean, but this
            one will tell you if the current page is the first page in the wizard.
        </li>
    </ul>

    <h6>Useful methods on the wizard</h6>
    <ul class="list">
        <li>
            <code class="clr-code">wizard.open()</code> opens the wizard.
        </li>
        <li>
            <code class="clr-code">wizard.close()</code> just closes the wizard but bypasses
            event emitters associated with finish and cancel. Use this method on the wizard
            to implement custom cancel or finish methods in your host component to avoid any
            circular event emission.
        </li>
        <li>
            You can pass a boolean to <code class="clr-code">wizard.toggle()</code> to hide
            or show the wizard. <code class="clr-code">wizard.toggle(false)</code> will hide
            the wizard and <code class="clr-code">wizard.toggle(true)</code> will show it.
        </li>
        <li>
            <code class="clr-code">wizard.previous()</code> will try to move the wizard to the
            page immediately before the current page &mdash; if it can. It will fail silently
            if the current page has no previous page to which it can move.
        </li>
        <li>
            <code class="clr-code">wizard.next()</code> will try to move the wizard to the page
            immediately after the current page. It will also fail silently if the current page
            has no page that follows it.
        </li>
        <li>
            <code class="clr-code">wizard.finish()</code> will initiate the routines associated
            with completing the wizard, as if a finish button had been clicked on the last page.
            You can use <code class="clr-code">wizard.finish()</code> in your code if you are
            using a custom finish or danger button on the last page in your wizard.
        </li>
        <li>
            <code class="clr-code">wizard.cancel()</code> will invoke the cancel routines for the
            wizard as if the close “X” or cancel button had been clicked. This should probably only
            be used if you have a custom cancel button that you need to wire up or if you want to
            cancel the wizard programmatically. If you are trying to circumvent the wizard’s cancel
            routine altogether, you would be better off using
            <code class="clr-code">wizard.close()</code>.
        </li>
        <li>
            <code class="clr-code">wizard.goTo()</code> accepts a string representing the id of the
            page you want the wizard to make current as a parameter. If you have references to
            your pages in your host component, the page id can be retrieved with 
            <code class="clr-code">wizardpage.id</code> and can be passed into 
            <code class="clr-code">wizard.goTo()</code> &mdash; 
            <code class="clr-code">this.wizard.goTo(this.wizardpage.id)</code>. Note that
            <code class="clr-code">wizard.goTo()</code> checks to see if preceding pages have been
            completed before navigating to the specified page. If they have not been, it doesn’t
            do anything.
        </li>
        <li>
            <code class="clr-code">wizard.reset()</code> resets all pages' completed states to false
            and makes the first page in the wizard the current page &mdash; as if the wizard had
            never been opened before. See the demo below for a more extensive example and explanation.
        </li>
    </ul>

    <h5>The wizard page</h5>

    <p>
        Besides the wizard, the second most important component is the wizard page. This is
        because users often want to customize at the page level, instead of the wizard level.
    </p>
    <p>
        Just like the wizard, the wizard page needs an expected element within it or it will
        throw an error. Each wizard page needs a 
        <code class="clr-code">&lt;ng-template clrPageTitle&gt;</code> templateRef inside of
        it. Without this, the wizard page will have an existential crisis and not know what to
        call itself.
    </p>
    <p>
        By default, the content of the <code class="clr-code">&lt;ng-template clrPageTitle&gt;</code>
        templateRef will appear as the title in the content area of the wizard when the page
        is current as well as in the page's associated link in the step nav to the left.
    </p>
    <p>
        You can also save a reference to a wizard page in your host component if you want.
        Each page has hooks to the nav service and page collection providers shared between
        the wizard and its subcomponents.
    </p>

<pre><code clr-code-highlight="language-typescript">@Component(&#123;
    ...
&#125;)
export class WizardJumpToDemo &#123;
    @ViewChild("firstPage") wizardPage_1: WizardPage;
    @ViewChild("secondPage") wizardPage_2: WizardPage;

    get pageAreDone(): boolean &123;
        return this.firstPage.completed &amp;&amp; this.secondPage.completed;
    &125;
</code></pre>

<pre><code clr-code-highlight="language-html">&lt;clr-wizard [(clrWizardOpen)]="open">
    &lt;clr-wizard-title&gt;Your Wizard&lt;/clr-wizard-title&gt;
    &lt;clr-wizard-page #firstPage&gt;
        ...
    &lt;/clr-wizard-page&gt;
    &lt;clr-wizard-page #secondPage&gt;
        ...
    &lt;/clr-wizard-page&gt;
    ...
</code></pre>

    <h6>Inputs of note</h6>
    <ul class="list">
        <li>
            <code class="clr-code">clrWizardPageNextDisabled</code> is a boolean that
            disables the next button. It can be used to force validation on the current
            page before allowing users to move to the next page or finish a wizard.
            This is <code class="clr-code">false</code> by default.
        </li>
        <li>
            <code class="clr-code">clrWizardPagePreventDefault</code> is a boolean that
            circumvents all actions (cancel, finish, next, and previous) when the page
            is current. This can be used in combination with the outputs below to write
            your own wizard navigation procedures. This input is
            <code class="clr-code">false</code> by default.
        </li>
        <li>
            Most users, however, only want to monitor or circumvent the cancellation
            of the wizard. <code class="clr-code">clrWizardPagePreventDefaultCancel</code>
            does that. It is a boolean input that, if set to true, prevents the cancel
            action from firing when the page is current. Also
            <code class="clr-code">false</code> by default.
        </li>
    </ul>

    <h6>Outputs of note</h6>
    <ul class="list">
        <li>
            <code class="clr-code">clrWizardPageOnCommit</code> is an output that emits
            after a page is marked completed by user action. Generally, this happens
            after danger, finish, or next buttons are clicked. It will not be fired
            if the page is marked completed programmatically.
        </li>
        <li>
            <code class="clr-code">clrWizardPageOnLoad</code> is emitted after a page is
            made the current page. It cannot circumvent making a page current but it
            will notify you when a page has been made current and it delivers the
            page’s id as a string.
        </li>
        <li>
            <code class="clr-code">clrWizardPageOnCancel</code> is an output that fires
            when a user's action on a page initiates the wizard’s cancel routine. This
            output, combined with the <code class="clr-code">clrWizardPagePreventDefaultCancel</code>
            or <code class="clr-code">clrWizardPagePreventDefault</code> inputs, allows you
            to customize or rewrite the cancellation of a wizard from a page level.
        </li>
        <li>
            Wizard pages also have a set of outputs that emit when different buttons
            are clicked in the wizard. Note that these events are only emitted for the
            page when the page is current. These outputs include:
            <code class="clr-code">clrWizardPageFinish</code> when the finish button is
            clicked, <code class="clr-code">clrWizardPagePrevious</code> when the previous button
            is clicked, <code class="clr-code">clrWizardPageNext</code> when the next button
            is clicked, <code class="clr-code">clrWizardPageDanger</code> when a danger button
            is clicked, <code class="clr-code">clrWizardPagePrimary</code> when a
            next/finish/danger button is clicked, and
            <code class="clr-code">clrWizardPageCustomButton</code> when any custom button
            is clicked. All of these outputs (and <code class="clr-code">clrWizardPageOnCancel</code>)
            can be combined with the <code class="clr-code">clrWizardPagePreventDefault</code>
            input to create a unique, page-based behavior. More examples are available
            in the demos below.
        </li>
    </ul>

    <h6>Useful properties of the wizard page</h6>
    <ul class="list">
        <li>
            <code class="clr-code">wizardpage.id</code> returns the id of the page as a string.
        </li>
        <li>
            <code class="clr-code">wizardpage.completed</code> is a boolean that tells you if
            the page has been completed or not. If <code class="clr-code">true</code>, the page
            has been completed. If <code class="clr-code">false</code>, it has not.
        </li>
        <li>
            <code class="clr-code">wizardpage.current</code> is a boolean tells you if the page
            is the current page or not.
        </li>
    </ul>

    <h6>Useful methods of the wizard page</h6>
    <ul class="list">
        <li>
            <code class="clr-code">wizardpage.makeCurrent()</code> tells the nav service to make
            <code class="clr-code">wizardpage</code> the current page. This method circumvents
            checks to see if the page can be made current. Use 
            <code class="clr-code">wizard.goTo()</code> if you want to nav service to validate
            whether the specified page can be made current or not.
        </li>
    </ul>

    <h5>Providers (Services)</h5>

    <p>
        The Clarity wizard has a number of services (providers) that are created by the wizard
        and shared among all of its subcomponents. The two that you are most likely to interact
        with are the <code class="clr-code">WizardNavigationService</code> and
        <code class="clr-code">PageCollectionService</code>.
    </p>

    <h6>WizardNavigationService</h6>

    <p>
        The <code class="clr-code">WizardNavigationService</code> or “nav service” is the wizard’s
        executive assistant. It communicates with the wizard, the pages, and the
        <code class="clr-code">PageCollectionService</code> to make sure everyone stays in sync.
        Most of what the nav service does is already available to you through convenience methods
        on the wizard. Methods like <code class="clr-code">next()</code>,
        <code class="clr-code">previous()</code>, and <code class="clr-code">finish()</code>.
    </p>
    <p>
        It may have seemed, initially, that the wizard was super-helpful and doing lots of work.
        But the truth is the nav service does all the work. The wizard just gets all the credit!
    </p>
    <p>
        Because much of what the nav service does is behind-the-scenes, there is really only
        one method on the nav service that may interest you:
    </p>

    <ul class="list">
        <li>
            <code class="clr-code">wizard.navService.goTo()</code> takes either the id of a page
            or the page object itself and checks to see if it can make the page current. This is
            slightly more flexible than <code class="clr-code">wizard.goTo()</code> which only
            takes a page id.
        </li>
    </ul>

    <h6>PageCollectionService</h6>

    <p>
        The <code class="clr-code">PageCollectionService</code> &mdash; or “page collection” &mdash;
        groups all of the pages in the wizard together and acts as kind of a librarian. If you
        are looking for a page or even a group of pages, the page collection has you covered.
        The page collection also handles a small set of bulk actions on the pages in a wizard.
    </p>

    <p><b>Properties</b></p>

    <ul class="list">
        <li>
            <code class="clr-code">wizard.pageCollection.pages</code> is a
            <code class="clr-code">QueryList</code> of all the pages in a wizard.
        </li>
        <li>
            <code class="clr-code">wizard.pageCollection.pagesAsArray</code> is
            a convenient getter that returns
            <code class="clr-code">wizard.pageCollection.pages</code> as an array of page objects.
        </li>
    </ul>

    <p><b>Methods</b></p>
    <ul class="list">
        <li>
            If you know a page’s id, you can pass it as a string parameter to
            <code class="clr-code">wizard.pageCollection.getPageById()</code> and it will
            return the page if it exists in the page collection.
        </li>
        <li>
            Alternatively, you can pass the page’s index in the list of pages as a number
            parameter to <code class="clr-code">wizard.pageCollection.getPageByIndex()</code>
            to get the page returned back to you.
        </li>
        <li>
            If you have a page and you need to know where it is in the list of pages, you
            can pass the page object as a parameter to
            <code class="clr-code">wizard.pageCollection.getPageIndex()</code>
            and it will return the page’s numeric index.
        </li>
        <li>
            Passing a page object to <code class="clr-code">wizard.pageCollection.getPreviousPage()</code>
            as a parameter will return you the page before it in the collection or null
            if your page object is the first page in the collection.
        </li>
        <li>
            Continuing the trend, you can pass a page object as a parameter to
            <code class="clr-code">wizard.pageCollection.getNextPage()</code> and it will
            return the page after your page object in the collection or null if your
            page object is the last page in the collection.
        </li>
        <li>
            <code class="clr-code">wizard.pageCollection.updateCompletedStates()</code>
            is a function that cleans up the page collection by figuring out the first page
            marked as incomplete and the collection and then marking every page after
            it incomplete as well. This is a useful method if you handle a lot of page
            state programmatically.
        </li>
    </ul>


    <h3 id="guidelines">Usage</h3>

    <p>Use a wizard to present a series of steps for completing a complex workflow, such as installation. A wizard simplifies the workflow by directing users serially through the tasks.</p>

    <p>If the user doesn’t need to complete the workflow in a predefined order, use a <a routerLink="/documentation/modals">modal</a> instead.</p>

    <h4 id="base-wizard-size-on-use-case">Base Wizard size on use case</h4>

    <p>BSizes are 576 px, 864 px and 1056 px (default). The best design provides a good balance between white space and the number of elements per page. Overloading a page with too many controls can be a problem as can having many sparsely-populated pages.</p>

    <h4 id="title">Title</h4>

    <p>Typically task-based, the title should summarize the workflow, for example, Create Hardware Profile.</p>

    <h4 id="steps">Steps</h4>
    <div class="row buttons-modal-gfx">
        <div class="col-md-6 col-sm-12 flex-xs-middle">
            <img src="assets/images/documentation/wizards/New_wizard.png" alt="Buttons on inner wizard pages" style="max-width:100%;" />
        </div>

        <div class="col-md-5 offset-md-1 col-sm-12 clrweb-wizardsteps-block">
            <h4>Streamline the number of steps</h4>
            <p>
                A wizard should be at least two steps. Otherwise, a modal will suffice. Also, avoid vertical scrolling of steps. At the default size, the steps scroll at 14 lines.
            </p>

            <h4>Non-branching wizards are preferable</h4>
            <p>
                However, if a user choice results in a change in the number of steps, make the change early in the workflow. Otherwise, users might lose track of the navigation path.
            </p>

            <h4>Steps titles should be concise and direct</h4>
            <p>
                To help readers scan the text, use sentence-style caps and no ending punctuation. Avoid text that is so long it wraps to the next line.
            </p>
        </div>
    </div>

    <h4 id="pages">Pages</h4>

    <h6 id="use-the-header-to-set-context">Use the header to set context</h6>

    <p>By default, the page header is the same text as the selected step. If needed, enhance the header text to clarify meaning.</p>

    <h6 id="ensure-content-is-cohesive">Ensure content is cohesive</h6>

    <p>All text and components should support the goal or purpose of the page.</p>

    <p>Avoid:</p>

    <ul class="list">
        <li>Putting more than one task on a page. Pages are easier to use when they present a single step of the workflow.</li>
        <li>Opening a modal or wizard from within a wizard. This increases the complexity of the workflow.</li>
        <li>Putting so much content on a page that it scrolls.</li>
    </ul>

    <h6 id="buttons-are-right-aligned-in-the-footer">Buttons are right-aligned, in the footer</h6>

    <p>Right alignment supports the Z-pattern layout. The primary button is in the rightmost position.</p>

    <table class="table-noborder">
        <tbody>
            <tr>
                <td class="left">First wizard page</td>
                <td class="left">
                    <img src="assets/images/documentation/wizards/Wizard_buttons_1.png?1481774902655027000" width="70%" height="70%" alt="Buttons on first page of wizard" />
                </td>
            </tr>
            <tr>
                <td class="left">Inner wizard pages</td>
                <td class="left">
                    <img src="assets/images/documentation/wizards/Wizard_buttons_2.png?1481774902655027000" width="70%" height="70%" alt="Buttons on wizard inner pages" />
                </td>
            </tr>
            <tr>
                <td class="left">Last page</td>
                <td class="left">
                    <img src="assets/images/documentation/wizards/Wizard_buttons_3.png?1481774902655027000" width="70%" height="70%" alt="Buttons on final wizard page" />
                </td>
            </tr>
        </tbody>
    </table>

    <h6 id="cancel-and-close">Cancel and Close</h6>

    <p>Wizards have both a Close and Cancel button. The Close button is in the upper right corner as a visual affordance and for accessibility reasons.</p>

    <p>Clicking outside the wizard should not dismiss it. Users might accidentally click outside the wizard and lose data.</p>

    <h6 id="scrolling">Scrolling</h6>

    <p>Some wizard pages might require scrolling. The title and buttons remain in place when the content scrolls.</p>

    <p>Clarity does not use horizontal lines to define the scrollable area. This keeps the UI clean and simple. Also, a line above the buttons makes it appear as if all content is visible.</p>

    <h6 id="validation">Validation</h6>

    <p>Validation of user input can occur at the field level, the page level, and when the user finishes the wizard. This control allows users to complete actions with minimal risk of error or data loss.</p>

    <p>For more information on validation, see <a routerLink="/documentation/input-fields">input fields</a>.</p>

</article>
