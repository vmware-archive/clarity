<!--
  ~ Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.
  ~ This software is released under MIT license.
  ~ The full license information can be found in LICENSE in the root directory of this project.
  -->
<clr-doc-wrapper [ng]="ng" [ui]="ui" [title]="title" [newLayout]="newLayout">
    <article>

        <h5 class="component-summary" id="tree-view-header">
            A tree is a hierarchical component that shows the visual representation
            of the parent-child relationship between nodes.
        </h5>

        <div id="design-guidelines">
            <h3>Three Main Variations</h3>

            <div class="clr-row">
                <div class="clr-col-12 clr-col-md-5">
                    <h4>Basic Tree</h4>
                    <p>
                        A basic tree provides a tree structure with named nodes and an
                        arrow to expand and collapse child nodes.
                    </p>
                </div>
                <div class="clr-col-12 clr-col-md-6 clr-offset-md-1">
                    <div class="clrweb-DoxMedia has-h4-margin">
                        <div class="clrweb-DoxMedia-block">
                            <div class="clrweb-DoxMedia-img is-left-aligned">
                                <clr-tree-basic-demo></clr-tree-basic-demo>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="clr-row">
                <div class="clr-col-12 clr-col-md-5">
                    <h4>Basic Tree With Icons</h4>
                    <p>
                        A tree can include icons to represent the type of nodes within that group.
                        Icons appear between the collapse/expand arrow and the parent node title.
                    </p>
                    <p>
                        When using icons in a tree, make sure to use them on all nodes.
                        Do not alternate between using and not using icons within the same tree.
                    </p>
                    <p>
                        If using a tree in the context of other components, make sure those icons
                        are distinctive and easily recognizable. Use neutral colors to avoid
                        overloading the tree and related components with colors and shapes.
                    </p>
                </div>
                <div class="clr-col-12 clr-col-md-6 clr-offset-md-1">
                    <div class="clrweb-DoxMedia has-h4-margin">
                        <div class="clrweb-DoxMedia-block">
                            <div class="clrweb-DoxMedia-img is-left-aligned">
                                <clr-tree-view-dynamic-demo></clr-tree-view-dynamic-demo>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="clr-row">
                <div class="clr-col-12 clr-col-md-5">
                    <h4>Checkbox Tree</h4>
                    <p>
                        A checkbox tree features checkboxes between the collapse/expand
                        arrow and the name to indicate whether a node is selected. A
                        parent node with children that are both selected and not selected
                        is shown with an “indeterminate” state.
                    </p>
                    <p>
                        Checkbox trees should not be used together with icons for the nodes.
                        As with icon trees, make sure to put checkboxes on all nodes of a
                        checkbox tree. Do not alternate between types of trees in a checkbox
                        tree.
                    </p>
                </div>
                <div class="clr-col-12 clr-col-md-6 clr-offset-md-1">
                    <div class="clrweb-DoxMedia has-h4-margin">
                        <div class="clrweb-DoxMedia-block">
                            <div class="clrweb-DoxMedia-img is-left-aligned">
                                <clr-small-selection-tree-demo></clr-small-selection-tree-demo>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <h3>Style</h3>

            <p>
                The styling of each piece of a tree node is consistent across the different types of trees.
            </p>

            <div class="clr-row">
                <div class="clr-col-12 clr-col-md-5">
                    <h4>Touch Targets</h4>
                    <p>
                        The dimensions of the expand/collapse arrow and the node title allow
                        for a comfortable touch target allowing use with a mouse or a touch screen.
                    </p>
                </div>
                <div class="clr-col-12 clr-col-md-6 clr-offset-md-1">
                    <div class="clrweb-DoxMedia has-h4-margin">
                        <div class="clrweb-DoxMedia-block">
                            <div class="clrweb-DoxMedia-img">
                                <img
                                        src="assets/images/documentation/tree-view/example_tree_touch.svg"
                                        alt="Touch Targets"/>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="alert alert-info has-margin-top-b2">
                <div class="alert-items">
                    <div class="alert-item static">
                        <div class="alert-icon-wrapper">
                            <clr-icon class="alert-icon" shape="info-circle"></clr-icon>
                        </div>
                        <div class="alert-text">
                            Touch Targets are relevant even outside of a mobile form factor.
                            Many new desktop environments, especially those running Windows,
                            allow for the use of a touch screen and should be considered
                            when designing your applications.
                        </div>
                    </div>
                </div>
            </div>

            <h3>Behavior</h3>
            <p>
                To explain the behavior of the tree, here is the terminology we’ll be using in this section:
            </p>

            <div class="clr-row">
                <div class="clr-col-12 clr-col-md-4">
                    <h6>Highlight</h6>
                    <p>Click on a node in the tree to either “highlight” it or navigate to its relative content.</p>
                </div>
                <div class="clr-col-12 clr-col-md-4">
                    <h6>Select</h6>
                    <p>Choose items to apply an action. For example, selecting a checkbox in the tree.</p>
                </div>
                <div class="clr-col-12 clr-col-md-4">
                    <h6>Expand / Collapse</h6>
                    <p>Use the arrow to the left of a node to expand or collapse a node in the tree.</p>
                </div>
            </div>

            <h3>Interacting With Nodes</h3>

            <div class="clr-row">
                <div class="clr-col-12 clr-col-md-5">
                    <h4>Expanding / Collapsing Nodes</h4>
                    <p>
                        To expand or collapse a parent node, the user clicks on the expand/collapse arrow.
                        Clicking on the node item itself does not expand or collapse a node.
                        It serves as a highlighting mechanism.
                    </p>
                    <p>
                        In read-only trees where highlighting is not an option,
                        this pattern remains true for consistency.
                    </p>
                </div>
                <div class="clr-col-12 clr-col-md-6 clr-offset-md-1">
                    <div class="clrweb-DoxMedia has-h4-margin">
                        <div class="clrweb-DoxMedia-block">
                            <div class="clrweb-DoxMedia-img is-left-aligned">
                                <img
                                        src="assets/images/documentation/tree-view/example_tree_interacting.svg"
                                        alt="Interacting With Nodes"/>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="clr-row">
                <div class="clr-col-12 clr-col-md-5">
                    <h4>Highlighting Tree Nodes</h4>
                    <p>
                        To navigate to a content area based on a tree node or to highlight
                        a tree node in order to take a subsequent action based on
                        the selection, a user clicks on the node title itself.
                    </p>
                </div>
                <div class="clr-col-12 clr-col-md-6 clr-offset-md-1">
                    <div class="clrweb-DoxMedia has-h4-margin">
                        <div class="clrweb-DoxMedia-block">
                            <div class="clrweb-DoxMedia-img is-left-aligned">
                                <img
                                        src="assets/images/documentation/tree-view/example_tree_highlighting.svg"
                                        alt="Highlighting Tree Nodes"/>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="clr-row">
                <div class="clr-col-12 clr-col-md-5">
                    <h4>Interacting With Checkbox Trees</h4>
                    <p>
                        With a checkbox tree, a user is able to perform one or a
                        combination of three actions by clicking on one of three
                        distinct targets:
                    </p>
                    <ol class="list">
                        <li style="margin-top:24px">
                            Expanding and Collapsing: a user is able to perform this
                            action by clicking on the expand / collapse arrow.
                        </li>
                        <li style="margin-top:24px">
                            Checking a Checkbox: this would require clicking on the
                            checkbox itself to check or uncheck a treenode. This
                            will also affect the status of the parent node’s checkbox.
                        </li>
                        <li style="margin-top:24px">
                            Highlighting Tree Node: a user can highlight a tree node by
                            clicking on the name (label) of the tree node. This allows
                            for the possibility of loading content based on selection
                            to provide more information on a tree node.
                        </li>
                    </ol>
                </div>
                <div class="clr-col-12 clr-col-md-6 clr-offset-md-1">
                    <div class="clrweb-DoxMedia has-h4-margin">
                        <div class="clrweb-DoxMedia-block">
                            <div class="clrweb-DoxMedia-img is-left-aligned">
                                <img
                                        src="assets/images/documentation/tree-view/example_tree_checkbox_interacting.svg"
                                        alt="Interacting with Checkbox Trees"/>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <h3>Loading Data</h3>
            <p>The way to load data within the tree is based on the scenario in which the tree is being used.</p>

            <div class="clr-row">
                <div class="clr-col-12 clr-col-md-5">
                    <h6>Load Parent Nodes First</h6>
                    <p>
                        With a dynamic tree, make sure to load the parent
                        nodes first and then lazy load child nodes when requested.
                    </p>
                    <p>
                        A general goal to keep in mind is that you want to minimize
                        the time a user needs to spend before their first
                        interaction with the tree as well as every
                        subsequent interaction afterwards.
                    </p>
                </div>
                <div class="clr-col-12 clr-col-md-6 clr-offset-md-1">
                    <div class="clrweb-DoxMedia has-h6-margin">
                        <div class="clrweb-DoxMedia-block">
                            <div class="clrweb-DoxMedia-img is-left-aligned">
                                <img
                                        src="assets/images/documentation/tree-view/example_tree_lazyloading.svg"
                                        alt="Loading Data"/>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div id="code-examples">
            <h3 id="examples">Code &amp; Examples</h3>

            <div class="clr-row" style="margin-top: 24px">
                <div class="clr-col-12">
                    <ul class="list demo-list">
                        <li><a routerLink="." fragment="basic-tree">Basic tree</a></li>
                        <li><a routerLink="." fragment="expanded-nodes">Keeping track of expanded nodes</a></li>
                        <li><a routerLink="." fragment="routing-tree">Routing using a tree</a></li>
                        <li><a routerLink="." fragment="dynamically-generated">Generating A tree dynamically</a></li>
                        <li><a routerLink="." fragment="checkbox-tree">Checkbox tree</a></li>
                        <li><a routerLink="." fragment="boolean-selection">Binding selection to a boolean</a></li>
                        <li><a routerLink="." fragment="lazy-loading">Lazy loading children</a></li>
                        <li><a routerLink="." fragment="lazy-loading-selection">Lazy loading and selection</a></li>
                        <li><a routerLink="." fragment="lazy-loading-recursive">Lazy-loading recursive trees</a></li>
                        <li><a routerLink="." fragment="api-tables">Summary of options</a></li>
                    </ul>
                </div>
            </div>

            <h3 id="basic-tree">Basic Tree</h3>

            <p>
                A basic tree can be created by simply nesting
                <code class="clr-code">clr-tree-node</code> components at will.
                To pre-expand a node, you can use the <code class="clr-code">[clrExpanded]</code> input.
            </p>

            <section class="clr-demo">
                <clr-tree-basic-dm-demo></clr-tree-basic-dm-demo>
            </section>

            <p>
                <a routerLink="." fragment="examples">Back to navigation</a>
            </p>

            <h3 id="expanded-nodes">Keeping track of expanded nodes</h3>

            <p>
                If you need to keep track of whether certain nodes are expanded or collapsed,
                each tree node offers a <code class="clr-code">[(clrExpanded)]</code> boolean two-way binding.
            </p>

            <section class="clr-demo">
                <clr-tree-node-label-change-expand-demo></clr-tree-node-label-change-expand-demo>
            </section>

            <p>
                <a routerLink="." fragment="examples">Back to navigation</a>
            </p>

            <h3 id="routing-tree">Routing using a Tree</h3>

            <p>
                Use the <code class="clr-code">.clr-treenode-link</code> class to style content inside of a Tree Node
                as clickable. To indicate an active Tree Node use the <code class="clr-code">.active</code> class
                along with <code class="clr-code">.clr-treenode-link</code>.
            </p>

            <section class="clr-demo">
                <clr-tree-node-routing-demo></clr-tree-node-routing-demo>
            </section>

            <p>
                <a routerLink="." fragment="examples">Back to navigation</a>
            </p>

            <h3 id="dynamically-generated">Generating A Tree Dynamically</h3>

            <section class="clr-demo">
                <clr-tree-view-dynamic-demo
                        [clrDemoShowCode]="true"
                        [clrDemoShowHalf]="true"></clr-tree-view-dynamic-demo>
            </section>

            <p>
                <a routerLink="." fragment="examples">Back to navigation</a>
            </p>

            <h3 id="checkbox-tree">Checkbox Tree</h3>

            <p>
                Selection on the whole tree is enabled as soon as one of the nodes uses the
                <code class="clr-code">[(clrSelected)]</code> two-way binding. This two-way binding can receive
                either booleans or <code class="clr-code">ClrSelectedState</code> enum values, which can be
                <code class="clr-code">UNSELECTED</code>, <code class="clr-code">SELECTED</code> or
                <code class="clr-code">INDETERMINATE</code>. It will however always output
                <code class="clr-code">ClrSelectedState</code> enum values because the node could become indeterminate,
                so true two-way binding should be used on a <code class="clr-code">ClrSelectedState</code> property.
            </p>
            <p>
                As with any two-way binding, the input can be used to pre-select nodes or dynamically select them
                due to external actions.
            </p>

            <section class="clr-demo">
                <clr-selection-tree-demo></clr-selection-tree-demo>
            </section>


            <h3 id="boolean-selection">Binding selection to a boolean</h3>

            <p>
                If you know a specific node can never become indeterminate, you probably want to use a boolean
                property on your node. As mentioned previously, <code class="clr-code">[(clrSelected)]</code>
                always outputs <code class="clr-code">ClrSelectedState</code> enum values, making two-way binding
                with a boolean problematic. The most straightforward solution is to use
                <a href="https://angular.io/guide/template-syntax#two-way-binding---">
                    the de-sugarized syntax of the two-way binding
                </a>, transforming the output to a boolean directly.
            </p>

            <section class="clr-demo">
                <clr-boolean-selection-tree-demo></clr-boolean-selection-tree-demo>
            </section>

            <p>
                <a routerLink="." fragment="examples">Back to navigation</a>
            </p>

            <h3 id="recursive-tree">Recursive tree</h3>

            <p>
                If the data you are displaying is recursive or has an unknown depth, you can use our
                <code class="clr-code">*clrRecursiveFor</code> structural directive to recursively iterate over
                your data. It has the same syntax as <code class="clr-code">*ngFor</code>, and accepts an additional
                <code class="clr-code">getChildren</code> parameter that receives a node and should return its
                children. Please note that it needs to be used inside of a
                <code class="clr-code">&lt;clr-tree&gt;</code> to function properly.
            </p>

            <section class="clr-demo">
                <clr-recursive-tree-demo></clr-recursive-tree-demo>
            </section>

            <p>
                <a routerLink="." fragment="examples">Back to navigation</a>
            </p>

            <h3 id="lazy-loading">Lazy-loading children</h3>

            <p>
                If your tree is too large to be fully build on initialization or getting the children of a node is
                an expensive operation like an HTTP request, you might want to lazy-load tree nodes, only loading
                the ones that are currently displayed. To lazy-load children for a simple tree component,
                you need to combine several features as follows:
            </p>
            <ul>
                <li>
                    use our <code class="clr-code">&lt;clr-tree&gt;</code> root component, giving it a
                    <code class="clr-code">[clrLazy]="true"</code> input,
                </li>
                <li>
                    leverage our <code class="clr-code">*clrIfExpanded</code> structural directive to only
                    instantiate children when they are displayed,
                </li>
                <li>
                    listen to the <code class="clr-code">(clrIfExpandedChange)</code> output
                    to fetch the children's data,
                </li>
                <li>
                    add a <code class="clr-code">[clrLoading]</code> boolean input to the node if fetching children
                    is asynchronous, to display a spinner while waiting for the data to be loaded.
                </li>
            </ul>

            <section class="clr-demo">
                <clr-lazy-loading-tree-demo></clr-lazy-loading-tree-demo>
            </section>

            <p>
                <a routerLink="." fragment="examples">Back to navigation</a>
            </p>

            <h3 id="lazy-loading-selection">Lazy-loading and selection</h3>

            <p>
                When lazy-loading nodes in a tree, Clarity only has partial information on the overall data
                and cannot link parent and children state as it does in the previous cases. For instance,
                in a lazy-loaded file system tree, our tree component does not know the contents of a folder until
                it is expanded. This means that if the user selects the folder without expanding it first we cannot
                output the selection change for the files, only for the folder itself. It is up to the application
                or up to the server to preserve consistency, ensuring files in the folder are selected if the folder
                itself is.
            </p>

            <section class="clr-demo">
                <clr-lazy-loading-selection-tree-demo></clr-lazy-loading-selection-tree-demo>
            </section>

            <p>
                <a routerLink="." fragment="examples">Back to navigation</a>
            </p>

            <h3 id="lazy-loading-recursive">Lazy-loading recursive trees</h3>

            <p>
                Lazy-loading data for recursive trees is actually the simplest case: as soon as you set
                <code class="clr-code">[clrLazy]="true"</code> on the parent
                <code class="clr-code">&lt;clr-tree&gt;</code>, the <code class="clr-code">getChildren</code>
                function will only be lazily called when a node becomes expanded,
                and supports both <code class="clr-code">Promise</code> and <code class="clr-code">Observable</code>
                return types if you need to fetch children asynchronously.
            </p>
            <p>
                By default, recursive trees will pre-load on level ahead to know if the currently displayed nodes are
                expandable of not. If you do not want this behavior and have a way of knowing if a node is
                expandable without fetching its children, you can prevent the extra loading by using the
                <code class="clr-code">[clrExpandable]</code> boolean input on nodes based on your own condition.
            </p>

            <section class="clr-demo">
                <clr-lazy-loading-recursive-tree-demo></clr-lazy-loading-recursive-tree-demo>
            </section>

            <p>
                <a routerLink="." fragment="examples">Back to navigation</a>
            </p>

            <h2 id="api-tables">Summary of Options</h2>

            <h4>Tree <code class="clr-code">&lt;clr-tree&gt;</code></h4>
            <table class="table">
                <thead>
                <tr>
                    <th class="left">Input/Output</th>
                    <th class="hidden-xs-down">Values</th>
                    <th class="hidden-xs-down">Default</th>
                    <th class="left">Effect</th>
                </tr>
                </thead>
                <tbody>
                <tr>
                    <td class="left">
                        <b>[(clrLazy)]</b>
                        <div class="hidden-sm-up">Type: boolean</div>
                        <div class="hidden-sm-up">Default: false</div>
                    </td>
                    <td class="hidden-xs-down">boolean</td>
                    <td class="hidden-xs-down">false</td>
                    <td class="left">
                        Indicates to the tree that children nodes should be lazy-loaded
                    </td>
                </tr>
                </tbody>
            </table>

            <h4>Tree Node <code class="clr-code">&lt;clr-tree-node&gt;</code></h4>
            <table class="table">
                <thead>
                <tr>
                    <th class="left">Input/Output</th>
                    <th class="hidden-xs-down">Values</th>
                    <th class="hidden-xs-down">Default</th>
                    <th class="left">Effect</th>
                </tr>
                </thead>
                <tbody>
                <tr>
                    <td class="left">
                        <b>[(clrSelected)]</b>
                        <div class="hidden-sm-up">Type: ClrSelectedState</div>
                        <div class="hidden-sm-up">Default: UNSELECTED</div>
                    </td>
                    <td class="hidden-xs-down">ClrSelectedState</td>
                    <td class="hidden-xs-down">UNSELECTED</td>
                    <td class="left">
                        Two-way binding on the state of a Tree Node: UNSELECTED, SELECTED or INDETERMINATE.
                    </td>
                </tr>
                <tr>
                    <td class="left">
                        <b>[(clrExpanded)]</b>
                        <div class="hidden-sm-up">Type: boolean</div>
                        <div class="hidden-sm-up">Default: false</div>
                    </td>
                    <td class="hidden-xs-down">boolean</td>
                    <td class="hidden-xs-down">false</td>
                    <td class="left">
                        Two-way binding on the expanded/collapsed state of the node.
                    </td>
                </tr>
                <tr>
                    <td class="left">
                        <b>[clrExpandable]</b>
                        <div class="hidden-sm-up">Type: boolean | undefined</div>
                        <div class="hidden-sm-up">Default: undefined</div>
                    </td>
                    <td class="hidden-xs-down">boolean | undefined</td>
                    <td class="hidden-xs-down">undefined</td>
                    <td class="left">
                        Forces a node to be expandable or node, regardless of its children.
                    </td>
                </tr>
                </tbody>
            </table>

            <h4>Recursive iterator <code class="clr-code">*clrRecursiveFor</code></h4>

            <table class="table">
                <thead>
                <tr>
                    <th class="left">Input/Output</th>
                    <th class="hidden-xs-down">Values</th>
                    <th class="hidden-xs-down">Default</th>
                    <th class="left">Effect</th>
                </tr>
                </thead>
                <tbody>
                <tr>
                    <td class="left">
                        <b>[clrRecursiveForOf]</b>
                        <div class="hidden-sm-up">Type: T | T[]</div>
                        <div class="hidden-sm-up">Default: none</div>
                    </td>
                    <td class="hidden-xs-down">T | T[]</td>
                    <td class="hidden-xs-down">none</td>
                    <td class="left">
                        Root node(s) of the recursive tree, to begin the iteration.
                    </td>
                </tr>
                <tr>
                    <td class="left">
                        <b>[clrRecursiveForGetChildren]</b>
                        <!-- TODO: Use ClrGetChildrenFunction<T> as soon as we have it -->
                        <div class="hidden-sm-up">Type: T => T[] | Promise&lt;T[]&gt; | Observable&lt;T[]&gt;</div>
                        <div class="hidden-sm-up">Default: none</div>
                    </td>
                    <!-- TODO: Use ClrGetChildrenFunction<T> as soon as we have it -->
                    <td class="hidden-xs-down">T => T[] | Promise&lt;T[]&gt; | Observable&lt;T[]&gt;</td>
                    <td class="hidden-xs-down">none</td>
                    <td class="left">
                        The function to call in order to iterate over the children of a node. Can return an
                        asynchronous result in the form of a Promise or an Observable.
                    </td>
                </tr>
                </tbody>
            </table>

            <h4><code class="clr-code">*clrIfExpanded</code> directive</h4>

            <table class="table">
                <thead>
                <tr>
                    <th class="left">Input/Output</th>
                    <th class="hidden-xs-down">Values</th>
                    <th class="hidden-xs-down">Default</th>
                    <th class="left">Effect</th>
                </tr>
                </thead>
                <tbody>
                <tr>
                    <td class="left">
                        <b>[(clrIfExpanded)]</b>
                        <div class="hidden-sm-up">Type: boolean</div>
                        <div class="hidden-sm-up">Default: false</div>
                    </td>
                    <td class="hidden-xs-down">boolean</td>
                    <td class="hidden-xs-down">false</td>
                    <td class="left">
                        Two-way binding on the expanded/collapsed state of the node.
                    </td>
                </tr>
                </tbody>
            </table>

            <h4>Loading directive <code class="clr-code">[clrLoading]</code></h4>

            <table class="table">
                <thead>
                <tr>
                    <th class="left">Input/Output</th>
                    <th class="hidden-xs-down">Values</th>
                    <th class="hidden-xs-down">Default</th>
                    <th class="left">Effect</th>
                </tr>
                </thead>
                <tbody>
                <tr>
                    <td class="left">
                        <b>[clrLoading]</b>
                        <div class="hidden-sm-up">Type: boolean</div>
                        <div class="hidden-sm-up">Default: false</div>
                    </td>
                    <td class="hidden-xs-down">boolean</td>
                    <td class="hidden-xs-down">false</td>
                    <td class="left">
                        Activates a spinner to indicate that children nodes are loading.
                    </td>
                </tr>
                </tbody>
            </table>
        </div>
    </article>
</clr-doc-wrapper>
